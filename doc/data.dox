// -*- mode: c++; mode: visual-line; mode: flyspell; fill-column: 100000 -*-
/*******************************************************************************
 * doc/data.dox
 *
 * Part of Project c7a.
 *
 * Copyright (C) 2015 Tobias Sturm <tobias.sturm@student.kit.edu>
 *
 * This file has no license. Only Chunk Norris can compile it.
 ******************************************************************************/

namespace c7a {
namespace data {

/******************************************************************************/
/** \page data Data Subsystem

The \ref DataManager is a facade for the subsystem access to remote and local data.

## DIAs-Partitions
\ref c7a::DIARef "Distributed immuteable arrays" are the central entities for addressing data inside a user's program.
DIAs can be materialized (data elements are held in external or internal memory) or not (DIA refers internally to upstream DIAs and how to transform elements).
Each worker holds a partition of each DIA.
Partitions are most likely not balanced across workers and some partitions might be even empty.
These partitions are addressed via a \ref c7a::data::DIAId "DIAId" that is generated in a deterministic manner, such that each worker generates the same sequence of DIAIds.
Access to elements of DIA partitions via their DIAId is provided via the \ref DataManager.

## Data Channels
Workers may need to exchange many data elements between each other in an asynchronous fashion.
Data exchanges are triggered by distributed operations.
\todo refer to list of distributed operations.

Multiple data exchanges of different distributed operations can happen concurrently.
Therefore an address-schema is required to distinguish \ref c7a::net::Channel "data channels".
We use the same approach as for the DIAs by using a \ref c7a::net::ChannelId "ChannelId" that is generated in a determistic fashion.
Access to these channels is provided through the \ref DataManager.

## Buffers and BufferChains
Data is stored in \ref BinaryBuffer instances which are blobs of memory (preferably allocated to a reasonable size).
\ref c7a::data::BinaryBufferBuilder "Builders" and \ref c7a::data::BinaryBufferReader "Readers" provide a convenient interface to store and retrieve primitive data types (int, long, string, ...).
Buffers can be chained together by using the \ref BufferChain.
Incoming data of data channels as well as the materialized DIA data elements are stored in BufferChains.
The \ref c7a::data::BufferChainManager is used to manage the mapping from ID (DIAId and ChannelId) to BufferChain.
BufferChains can append BinaryBuffers or can be closed.

## Address Schema
DIAs and Channels are addressed by IDs that are allocated via the DataManager by calling \ref c7a::data::DataManager::AllocateDIA() "AllocateDIA" and \ref c7a::data::DataManager::AllocateNetworkChannel() "AllocateNetworkChannel".
Each call of these methods alters the state of the \ref c7a::data::DataManager, thus the order in which these calls happen matters.
Workers must call the allocate in the same order to enforce a consisten naming for DIAs and \ref c7a::net::Channel "NetworkChannels".

## Iterators and Emitters
The central interface to access data consists of the \ref BlockIterator and the \ref BlockEmitter class.
Both instances can be retrieved by passing an id to the \ref DataManager.
When data is pushed / pulled via these classes, data elements are serialized if necessary.
Emitters and Iterators can access locally stored data and channel data by accessing \ref BufferChain instances.
Both types of emitters may buffer pushed elements until \ref BlockEmitter::Flush() "flush" or \ref BlockEmitter::Close() "close" is called. Thus elements might not be visible on the attached iterators until flush or closed was called.
Emitters and Iterators can operate concurrently - emitters can push data even after an iterator was created.
Emitters can close a BufferChain and Iterators provide a \ref BlockIterator::IsClosed() "IsClosed() method".
If multiple emitters exist, multiple calls to \ref BlockEmitter::Close() "close" lead to undefined behaviour.

## Examples
To write into the local storage and then read from it use:
\code
c7a::data::DIAId id = data_manager.AllocateDIA();
auto emitter = data_manager.GetLocalEmitter<std::string>(id);
emitter("foo");
emitter("bar");
emitter.Close();

auto iterator = data_manager.GetIterator<std::string>(id);
while(it.HasNext())
    std::cout << it.Next();
\endcode

To send and receive data over network channels use:
\code
int main() {
    c7a::data::ChannelId id = data_manager.AllocateNetworkChannel();

    //can be called concurrently
    Produce(data_manager, id);
    Consume(data_manager, id);
}

void Produce(c7a::data::DataManager& manager, c7a::data::ChannelId id) {
    //one emitter for each communication partner
    std::vector<BlockEmitter<int>> emitters = manager.GetNetworkEmitters<int>(id);

    //write some data to each worker
    for (auto& e : emitters) {
        e(42);
    }

    //Flush forces to send data over network -> will be visible in 'Consume()'
    for (auto& e : emitters) {
        e.Flush();
    }
}

void Consume(c7a::data::DataManager& manager, c7a::data::ChannelId id) {
    auto it = manager.GetIterator(id);

    //loop until every emitter in produce has been closed.
    while (!it.IsClosed()) {
        it.WaitForMore(); //returns instantly when data available or it was closed, blocks if not
        while (it.HasNext()) { //can return false even if more data is available
            std::cout << "received " << it.Next() << std::endl;
        }
    }
}
\endcode

*/

} // namespace data
} // namespace c7a

/******************************************************************************/
