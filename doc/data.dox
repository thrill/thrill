// -*- mode: c++; mode: visual-line; mode: flyspell; fill-column: 100000 -*-
/*******************************************************************************
 * doc/data.dox
 *
 * Part of Project c7a.
 *
 * Copyright (C) 2015 Tobias Sturm <tobias.sturm@student.kit.edu>
 *
 * This file has no license. Only Chunk Norris can compile it.
 ******************************************************************************/

namespace c7a {
namespace data {

/******************************************************************************/
/** \page data Data Subsystem

The \ref data::Manager is a facade for the subsystem access to remote and local data.

## Block, and BlockWriter and BlockReader

Serialized data is stored in Block objects, which are equally sized chunks of memory. Much of the other classes are needed to correctly handle splitting and combining of small and huge items and data types into Block chunks. This is what BlockWriter and BlockReader do: serialize and deserialize items (or arbitrary datatypes) into Blocks.

A BlockWriter fills a Block and delivers full Blocks to a BlockSink. See the inheritance diagram of BlockSink for available sinks; there are at least: File, BlockQueue, and ChannelSink.

A BlockReader is parameterized by a BlockSource concept class, which delivers Blocks to the Reader. The reader then deserializes items and arbitrary data types from the Blocks, and reads new a Block if a large item extends to it.

A BlockWriter has two additional signaling methods: \ref BlockWriter::Flush Flush() and \ref BlockWriter::Close Close() . Flush() is only needed when the buffering block should immediately be written to the BlockSink. Close() flushes the last block and no more items may be written.

The standard loop of a BlockReader consists of testing whether another item can be read via BlockReader::HasNext() and then fetching an item Using BlockReader::Next(). The method Next() must be parameterized with the serializable item to get. Beware that any items can be mixed together, and that they deserialization *must* match the serialization done by BlockWriter.


## Data Channels

Workers may need to exchange many data elements between each other in an asynchronous fashion. A Channel is a communication context to exchange large amounts of items between workers. Channels may be used by DOps to implemented distributed operations.

Multiple Channels of different distributed operations can exist concurrently. Therefore the Channel objects have to be allocated in a deterministic order via Manager::GetNewChannel().

See the documentation of Channel and ChannelMultiplexer on how to read and write to Channels.


# OLD DOC BY TOBI

## DIAs-Partitions
DIARef "Distributed immuteable arrays" are the central entities for addressing data inside a user's program.
DIAs can be materialized (data elements are held in external or internal memory) or not (DIA refers internally to upstream DIAs and how to transform elements).
Each worker holds a partition of each DIA.
Partitions are most likely not balanced across workers and some partitions might be even empty.
These partitions are addressed via a DIAId that is generated in a deterministic manner, such that each worker generates the same sequence of DIAIds.
Access to elements of DIA partitions via their DIAId is provided via the Manager.

## Address Schema
DIAs and Channels are addressed by unique IDs, which are allocated via the data::Manager by calling "AllocateDIA" and "AllocateNetworkChannel".
Each call of these methods alters the state of the Manager, thus the order in which these calls happen matters.
All workers must call the allocate in the same order to enforce a consistent naming for DIAs and \ref Channel "NetworkChannels".

## Iterators and Emitters
The central interface to access data consists of the Iterator and the Emitter class.
Both instances can be retrieved by passing an id to the Manager.
When data is pushed / pulled via these classes, data elements are serialized if necessary.
Emitters and Iterators can access locally stored data and channel data by accessing BufferChain instances.
Both types of emitters may buffer pushed elements until Emitter::Flush() "flush" or Emitter::Close() "close" is called. Thus elements might not be visible on the attached iterators until flush or closed was called.
Emitters and Iterators can operate concurrently - emitters can push data even after an iterator was created.
Emitters can close a BufferChain and Iterators provide a Iterator::IsFinished() "IsFinished() method".
If multiple emitters exist, multiple calls to Emitter::Close() "close" lead to undefined behaviour.
Iterators offer Iterator::HasNext() and Iterator::Next() as most ocmmon interface to read data sequentially. Iterator::Seek() can be used for internal use. Seek returns a base address and byte-length of the elements that where seeked. Seek always returns continuous memory and thus only operats on a single BinaryBufer. Iterator::Seek() can be called multiple times to return multiple memory ranges until all elements have been reached, as shown in the example below.

## Examples
To write into the local storage and then read from it use:
\code
c7a::data::DIAId id = data_manager.AllocateDIA();
auto emitter = data_manager.GetLocalEmitter<std::string>(id);
emitter("foo");
emitter("bar");
emitter.Close();

auto iterator = data_manager.GetIterator<std::string>(id);
while(it.HasNext())
    std::cout << it.Next();
\endcode

To send and receive data over network channels use:
\code
int main() {
    c7a::data::ChannelId id = data_manager.AllocateNetworkChannel();

    //can be called concurrently
    Produce(data_manager, id);
    Consume(data_manager, id);
}

void Produce(c7a::data::Manager& manager, c7a::data::ChannelId id) {
    //one emitter for each communication partner
    std::vector<Emitter<int>> emitters = manager.GetNetworkEmitters<int>(id);

    //write some data to each worker
    for (auto& e : emitters) {
        e(42);
    }

    //Flush forces to send data over network -> will be visible in 'Consume()'
    for (auto& e : emitters) {
        e.Flush();
    }
}

void Consume(c7a::data::Manager& manager, c7a::data::ChannelId id) {
    auto it = manager.GetIterator(id);

    //loop until every emitter in produce has been closed AND iterator is on end of chain
    while (!it.IsFinished()) {
        it.WaitForMore(); //returns instantly when data available or it was closed, blocks if not
        while (it.HasNext()) { //can return false even if more data is available
            std::cout << "received " << it.Next() << std::endl;
        }
    }
}
\endcode

Seek 100 elements from a Dia Partition
\code
    auto it = manager.GetIterator(id);
    size_t element_count = 0;
    while (element_count < 100) {
        void* data;
        size_t length;
        size_t elements_seeked = it.Seek(100 - element_count, &data, &length)
        //do something with data / length
        element_count += elements_seeked;
    }
\endcode

*/

} // namespace data
} // namespace c7a

/******************************************************************************/
