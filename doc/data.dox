// -*- mode: c++; mode: visual-line; mode: flyspell; fill-column: 100000 -*-
/*******************************************************************************
 * doc/data.dox
 *
 * Part of Project c7a.
 *
 * Copyright (C) 2015 Tobias Sturm <tobias.sturm@student.kit.edu>
 *
 * This file has no license. Only Chunk Norris can compile it.
 ******************************************************************************/

namespace c7a {
namespace data {

/******************************************************************************/
/** \page data Data Subsystem

The \ref data::Manager is a facade for the subsystem access to remote and local data.

## DIAs-Partitions
\ref c7a::api::DIARef "Distributed immuteable arrays" are the central entities for addressing data inside a user's program.
DIAs can be materialized (data elements are held in external or internal memory) or not (DIA refers internally to upstream DIAs and how to transform elements).
Each worker holds a partition of each DIA.
Partitions are most likely not balanced across workers and some partitions might be even empty.
These partitions are addressed via a \ref c7a::data::DIAId "DIAId" that is generated in a deterministic manner, such that each worker generates the same sequence of DIAIds.
Access to elements of DIA partitions via their DIAId is provided via the \ref data::Manager.

## Data Channels
Workers may need to exchange many data elements between each other in an asynchronous fashion.
Data exchanges are triggered by distributed operations.
\todo refer to list of distributed operations.

Multiple data exchanges of different distributed operations can happen concurrently.
Therefore an address-schema is required to distinguish \ref c7a::net::Channel "data channels".
We use the same approach as for the DIAs by using a \ref c7a::net::ChannelId "ChannelId" that is generated in a determistic fashion.
Access to these channels is provided through the \ref data::Manager.

## Buffers and BufferChains
Data is stored in \ref BinaryBuffer instances which are blobs of memory (preferably allocated to a reasonable size).
\ref c7a::data::BinaryBufferBuilder "Builders" and \ref c7a::data::BinaryBufferReader "Readers" provide a convenient interface to store and retrieve primitive data types (int, long, string, ...).
Buffers can be chained together by using the \ref BufferChain.
Incoming data of data channels as well as the materialized DIA data elements are stored in BufferChains.
The \ref c7a::data::BufferChainManager is used to manage the mapping from ID (DIAId and ChannelId) to BufferChain.
BufferChains can append BinaryBuffers or can be closed.

## Address Schema
DIAs and Channels are addressed by unique IDs, which are allocated via the data::Manager by calling \ref c7a::data::Manager::AllocateDIA() "AllocateDIA" and \ref c7a::data::Manager::AllocateNetworkChannel() "AllocateNetworkChannel".
Each call of these methods alters the state of the \ref c7a::data::Manager, thus the order in which these calls happen matters.
All workers must call the allocate in the same order to enforce a consistent naming for DIAs and \ref c7a::net::Channel "NetworkChannels".

## Iterators and Emitters
The central interface to access data consists of the \ref Iterator and the \ref Emitter class.
Both instances can be retrieved by passing an id to the \ref data::Manager.
When data is pushed / pulled via these classes, data elements are serialized if necessary.
Emitters and Iterators can access locally stored data and channel data by accessing \ref BufferChain instances.
Both types of emitters may buffer pushed elements until \ref Emitter::Flush() "flush" or \ref Emitter::Close() "close" is called. Thus elements might not be visible on the attached iterators until flush or closed was called.
Emitters and Iterators can operate concurrently - emitters can push data even after an iterator was created.
Emitters can close a BufferChain and Iterators provide a \ref Iterator::IsFinished() "IsFinished() method".
If multiple emitters exist, multiple calls to \ref Emitter::Close() "close" lead to undefined behaviour.
Iterators offer \ref Iterator::HasNext() and \ref Iterator::Next() as most ocmmon interface to read data sequentially. \ref Iterator::Seek() can be used for internal use. Seek returns a base address and byte-length of the elements that where seeked. Seek always returns continuous memory and thus only operats on a single BinaryBufer. \ref Iterator::Seek() can be called multiple times to return multiple memory ranges until all elements have been reached, as shown in the example below.

## Examples
To write into the local storage and then read from it use:
\code
c7a::data::DIAId id = data_manager.AllocateDIA();
auto emitter = data_manager.GetLocalEmitter<std::string>(id);
emitter("foo");
emitter("bar");
emitter.Close();

auto iterator = data_manager.GetIterator<std::string>(id);
while(it.HasNext())
    std::cout << it.Next();
\endcode

To send and receive data over network channels use:
\code
int main() {
    c7a::data::ChannelId id = data_manager.AllocateNetworkChannel();

    //can be called concurrently
    Produce(data_manager, id);
    Consume(data_manager, id);
}

void Produce(c7a::data::Manager& manager, c7a::data::ChannelId id) {
    //one emitter for each communication partner
    std::vector<Emitter<int>> emitters = manager.GetNetworkEmitters<int>(id);

    //write some data to each worker
    for (auto& e : emitters) {
        e(42);
    }

    //Flush forces to send data over network -> will be visible in 'Consume()'
    for (auto& e : emitters) {
        e.Flush();
    }
}

void Consume(c7a::data::Manager& manager, c7a::data::ChannelId id) {
    auto it = manager.GetIterator(id);

    //loop until every emitter in produce has been closed AND iterator is on end of chain
    while (!it.IsFinished()) {
        it.WaitForMore(); //returns instantly when data available or it was closed, blocks if not
        while (it.HasNext()) { //can return false even if more data is available
            std::cout << "received " << it.Next() << std::endl;
        }
    }
}
\endcode

Seek 100 elements from a Dia Partition
\code
    auto it = manager.GetIterator(id);
    size_t element_count = 0;
    while (element_count < 100) {
        void* data;
        size_t length;
        size_t elements_seeked = it.Seek(100 - element_count, &data, &length)
        //do something with data / length
        element_count += elements_seeked;
    }
\endcode

*/

} // namespace data
} // namespace c7a

/******************************************************************************/
